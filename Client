
DWORD WINAPI sendHeartbeats(LPVOID lpParam)
{
	//hThread3 = (HANDLE)lpParam;
    heartbeatSocket = (SOCKET)lpParam;

    while (true) {
        // Send a heartbeat message to the heartbeat server
        std::string heartbeatMessage = "heartbeat";
        int result = send(heartbeatSocket, heartbeatMessage.c_str(), heartbeatMessage.length(), 0);
       
		if (result == SOCKET_ERROR) {
        
			SplashShowNotConnection();
			ExitProcess(0);
            closesocket(heartbeatSocket);
            return 1;
        }










		//CloseHandle(hThread1);
		//CloseHandle(hThread2);
        Sleep(1000); // Wait for 1 second before sending the next heartbeat message
		//return 0;
    }


		//CloseHandle(hThread1);
		//CloseHandle(hThread2);

    return 0;
}


int ConnectTOServer (char add_ban,char BanReason[30])
{
	
	WORD		wVersionRequested;
	FILE		*PFupdater;
	WSADATA		wsaData;
	SOCKADDR_IN target; //Socket address information
	SOCKET		s;
	int			err;
	int			bytesSent;
	int			TryToConnect;
	char*		ptTime;
	char		tTime[12];



	//// ================ Heart Beat Server ================ //
	// Initialize Winsock
   // WSADATA wsaData;
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0) {
        std::cerr << "WSAStartup failed with error: " << result << std::endl;
        return 1;
    }

    // Create a socket for the heartbeat server
    SOCKET heartbeatSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (heartbeatSocket == INVALID_SOCKET) {
        std::cerr << "Failed to create socket with error: " << WSAGetLastError() << std::endl;
        WSACleanup();
        return 1;
    }


    // Resolve the IP address and port of the heartbeat server
    sockaddr_in heartbeatAddress;
    heartbeatAddress.sin_family = AF_INET;
	heartbeatAddress.sin_addr.s_addr = inet_addr (IPAddress); //Target IP
    heartbeatAddress.sin_port = htons(HEARTBeat_PORT);

	

    result = connect(heartbeatSocket, (SOCKADDR*)&heartbeatAddress, sizeof(heartbeatAddress));
    if (result == SOCKET_ERROR) {
       // std::cerr << "Failed to connect to heartbeat server with error: " << WSAGetLastError() << std::endl;
       // closesocket(heartbeatSocket);
       // WSACleanup();


		SplashShowNotConnection();
		WSACleanup();
		ExitProcess(0);

        return 1;
    }

    std::cout << "Connected to heartbeat server" << std::endl;

    // Create a thread to send heartbeat messages to the heartbeat server
    HANDLE heartbeatThread = CreateThread(NULL, 0, sendHeartbeats, (LPVOID)heartbeatSocket, 0, NULL);
    if (heartbeatThread == NULL) {
        std::cerr << "Failed to create heartbeat thread with error: " << GetLastError() << std::endl;
        closesocket(heartbeatSocket);
        WSACleanup();
        return 1;
    }


	//// ================ END Heart Beat Server ================ //


	closesocket( s );
	WSACleanup();


	return (0);
}



int CheckTheProccessIfClose(){



	/// ==== Keep Seek Hacks !!
    if (hThread1 != NULL) {
        DWORD dwExitCode;
		if (GetExitCodeThread(hThread1, &dwExitCode) && dwExitCode != STILL_ACTIVE ) {
            CloseHandle(hThread1);
			TerminateProcess(GetCurrentProcess(), 0);
			return 0;
			//ExitProcess(0);
            // First thread has terminated, restart it

			/*
            CloseHandle(hThread1);
            hThread1 = CreateThread(NULL, 0, Thread1, (LPVOID)hThread2, 0, NULL);
            if (hThread1 == NULL) {
                // Error handling
                return FALSE;
            }
			*/
			
		}else{
		 // Keep Elive The Theard for Suspend from hackers!
		 ResumeThread(hThread1);

		}
    }

	//sendHeartbeats
    // Check the status of the second thread
	if (hThread2 != NULL) {
        DWORD dwExitCode;
        if (GetExitCodeThread(hThread2, &dwExitCode) && dwExitCode != STILL_ACTIVE) {
            CloseHandle(hThread2);
			TerminateProcess(GetCurrentProcess(), 0);	
			return 0;


			//ExitProcess(0);



			/*
            // Second thread has terminated, restart it
            CloseHandle(hThread2);
            hThread2 = CreateThread(NULL, 0, Thread2, (LPVOID)hThread1, 0, NULL);
            if (hThread2 == NULL) {
                // Error handling
                CloseHandle(hThread1);
                return FALSE;
            }
		*/
        }else{
		 // Keep Elive The Theard for Suspend from hackers!
		 ResumeThread(hThread2);

		}


    }
	

	return 0;
}
